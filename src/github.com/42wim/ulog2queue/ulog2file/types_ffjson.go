// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: types.go
// DO NOT EDIT!

package main

import (
	"bytes"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *Context) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Context) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffj_t_Contextbase = iota
	ffj_t_Contextno_such_key
)

func (uj *Context) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Context) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Contextbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Contextno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffj_t_Contextno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Contextno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *esGeoIP) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *esGeoIP) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.Longitude != nil {
		buf.WriteString(`{ "longitude":`)
		fflib.AppendFloat(buf, float64(*mj.Longitude), 'g', -1, 64)
	} else {
		buf.WriteString(`{ "longitude":null`)
	}
	if mj.Latitude != nil {
		buf.WriteString(`,"latitude":`)
		fflib.AppendFloat(buf, float64(*mj.Latitude), 'g', -1, 64)
	} else {
		buf.WriteString(`,"latitude":null`)
	}
	buf.WriteByte(',')
	if len(mj.CountryName) != 0 {
		buf.WriteString(`"country_name":`)
		fflib.WriteJsonString(buf, string(mj.CountryName))
		buf.WriteByte(',')
	}
	if mj.Timezone != nil {
		if true {
			buf.WriteString(`"timezone":`)
			fflib.WriteJsonString(buf, string(*mj.Timezone))
			buf.WriteByte(',')
		}
	}
	if mj.ContinentCode != nil {
		if true {
			buf.WriteString(`"continent_code":`)
			fflib.WriteJsonString(buf, string(*mj.ContinentCode))
			buf.WriteByte(',')
		}
	}
	if len(mj.CityName) != 0 {
		buf.WriteString(`"city_name":`)
		fflib.WriteJsonString(buf, string(mj.CityName))
		buf.WriteByte(',')
	}
	if mj.CountryCode2 != nil {
		if true {
			buf.WriteString(`"country_code2":`)
			fflib.WriteJsonString(buf, string(*mj.CountryCode2))
			buf.WriteByte(',')
		}
	}
	if mj.RealRegionName != nil {
		if true {
			buf.WriteString(`"real_region_name":`)
			fflib.WriteJsonString(buf, string(*mj.RealRegionName))
			buf.WriteByte(',')
		}
	}
	if mj.RegionName != nil {
		if true {
			buf.WriteString(`"region_name":`)
			fflib.WriteJsonString(buf, string(*mj.RegionName))
			buf.WriteByte(',')
		}
	}
	if mj.IP != nil {
		if true {
			buf.WriteString(`"ip":`)
			fflib.WriteJsonString(buf, string(*mj.IP))
			buf.WriteByte(',')
		}
	}
	if mj.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = mj.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Coordinates != nil {
		if true {
			buf.WriteString(`"coordinates":`)

			{

				err = mj.Coordinates.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_esGeoIPbase = iota
	ffj_t_esGeoIPno_such_key

	ffj_t_esGeoIP_Longitude

	ffj_t_esGeoIP_Latitude

	ffj_t_esGeoIP_CountryName

	ffj_t_esGeoIP_Timezone

	ffj_t_esGeoIP_ContinentCode

	ffj_t_esGeoIP_CityName

	ffj_t_esGeoIP_CountryCode2

	ffj_t_esGeoIP_RealRegionName

	ffj_t_esGeoIP_RegionName

	ffj_t_esGeoIP_IP

	ffj_t_esGeoIP_Location

	ffj_t_esGeoIP_Coordinates
)

var ffj_key_esGeoIP_Longitude = []byte("longitude")

var ffj_key_esGeoIP_Latitude = []byte("latitude")

var ffj_key_esGeoIP_CountryName = []byte("country_name")

var ffj_key_esGeoIP_Timezone = []byte("timezone")

var ffj_key_esGeoIP_ContinentCode = []byte("continent_code")

var ffj_key_esGeoIP_CityName = []byte("city_name")

var ffj_key_esGeoIP_CountryCode2 = []byte("country_code2")

var ffj_key_esGeoIP_RealRegionName = []byte("real_region_name")

var ffj_key_esGeoIP_RegionName = []byte("region_name")

var ffj_key_esGeoIP_IP = []byte("ip")

var ffj_key_esGeoIP_Location = []byte("location")

var ffj_key_esGeoIP_Coordinates = []byte("coordinates")

func (uj *esGeoIP) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *esGeoIP) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_esGeoIPbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_esGeoIPno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_esGeoIP_CountryName, kn) {
						currentKey = ffj_t_esGeoIP_CountryName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_esGeoIP_ContinentCode, kn) {
						currentKey = ffj_t_esGeoIP_ContinentCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_esGeoIP_CityName, kn) {
						currentKey = ffj_t_esGeoIP_CityName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_esGeoIP_CountryCode2, kn) {
						currentKey = ffj_t_esGeoIP_CountryCode2
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_esGeoIP_Coordinates, kn) {
						currentKey = ffj_t_esGeoIP_Coordinates
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_esGeoIP_IP, kn) {
						currentKey = ffj_t_esGeoIP_IP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_esGeoIP_Longitude, kn) {
						currentKey = ffj_t_esGeoIP_Longitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_esGeoIP_Latitude, kn) {
						currentKey = ffj_t_esGeoIP_Latitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_esGeoIP_Location, kn) {
						currentKey = ffj_t_esGeoIP_Location
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_esGeoIP_RealRegionName, kn) {
						currentKey = ffj_t_esGeoIP_RealRegionName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_esGeoIP_RegionName, kn) {
						currentKey = ffj_t_esGeoIP_RegionName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_esGeoIP_Timezone, kn) {
						currentKey = ffj_t_esGeoIP_Timezone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_esGeoIP_Coordinates, kn) {
					currentKey = ffj_t_esGeoIP_Coordinates
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_esGeoIP_Location, kn) {
					currentKey = ffj_t_esGeoIP_Location
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_esGeoIP_IP, kn) {
					currentKey = ffj_t_esGeoIP_IP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_esGeoIP_RegionName, kn) {
					currentKey = ffj_t_esGeoIP_RegionName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_esGeoIP_RealRegionName, kn) {
					currentKey = ffj_t_esGeoIP_RealRegionName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_esGeoIP_CountryCode2, kn) {
					currentKey = ffj_t_esGeoIP_CountryCode2
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_esGeoIP_CityName, kn) {
					currentKey = ffj_t_esGeoIP_CityName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_esGeoIP_ContinentCode, kn) {
					currentKey = ffj_t_esGeoIP_ContinentCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_esGeoIP_Timezone, kn) {
					currentKey = ffj_t_esGeoIP_Timezone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_esGeoIP_CountryName, kn) {
					currentKey = ffj_t_esGeoIP_CountryName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_esGeoIP_Latitude, kn) {
					currentKey = ffj_t_esGeoIP_Latitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_esGeoIP_Longitude, kn) {
					currentKey = ffj_t_esGeoIP_Longitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_esGeoIPno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_esGeoIP_Longitude:
					goto handle_Longitude

				case ffj_t_esGeoIP_Latitude:
					goto handle_Latitude

				case ffj_t_esGeoIP_CountryName:
					goto handle_CountryName

				case ffj_t_esGeoIP_Timezone:
					goto handle_Timezone

				case ffj_t_esGeoIP_ContinentCode:
					goto handle_ContinentCode

				case ffj_t_esGeoIP_CityName:
					goto handle_CityName

				case ffj_t_esGeoIP_CountryCode2:
					goto handle_CountryCode2

				case ffj_t_esGeoIP_RealRegionName:
					goto handle_RealRegionName

				case ffj_t_esGeoIP_RegionName:
					goto handle_RegionName

				case ffj_t_esGeoIP_IP:
					goto handle_IP

				case ffj_t_esGeoIP_Location:
					goto handle_Location

				case ffj_t_esGeoIP_Coordinates:
					goto handle_Coordinates

				case ffj_t_esGeoIPno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Longitude:

	/* handler: uj.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Longitude = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.Longitude = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: uj.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Latitude = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.Latitude = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CountryName:

	/* handler: uj.CountryName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CountryName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timezone:

	/* handler: uj.Timezone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Timezone = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Timezone = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContinentCode:

	/* handler: uj.ContinentCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.ContinentCode = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.ContinentCode = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CityName:

	/* handler: uj.CityName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CityName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CountryCode2:

	/* handler: uj.CountryCode2 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.CountryCode2 = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.CountryCode2 = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RealRegionName:

	/* handler: uj.RealRegionName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.RealRegionName = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.RealRegionName = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RegionName:

	/* handler: uj.RegionName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.RegionName = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.RegionName = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IP:

	/* handler: uj.IP type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.IP = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.IP = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: uj.Location type=main.esGeoIPLocation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Location = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Location == nil {
			uj.Location = new(esGeoIPLocation)
		}

		err = uj.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Coordinates:

	/* handler: uj.Coordinates type=main.esGeoIPLocation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Coordinates = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Coordinates == nil {
			uj.Coordinates = new(esGeoIPLocation)
		}

		err = uj.Coordinates.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *esGeoIPLocation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *esGeoIPLocation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.Lon != nil {
		buf.WriteString(`{"lon":`)
		fflib.AppendFloat(buf, float64(*mj.Lon), 'g', -1, 64)
	} else {
		buf.WriteString(`{"lon":null`)
	}
	if mj.Lat != nil {
		buf.WriteString(`,"lat":`)
		fflib.AppendFloat(buf, float64(*mj.Lat), 'g', -1, 64)
	} else {
		buf.WriteString(`,"lat":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_esGeoIPLocationbase = iota
	ffj_t_esGeoIPLocationno_such_key

	ffj_t_esGeoIPLocation_Lon

	ffj_t_esGeoIPLocation_Lat
)

var ffj_key_esGeoIPLocation_Lon = []byte("lon")

var ffj_key_esGeoIPLocation_Lat = []byte("lat")

func (uj *esGeoIPLocation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *esGeoIPLocation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_esGeoIPLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_esGeoIPLocationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_esGeoIPLocation_Lon, kn) {
						currentKey = ffj_t_esGeoIPLocation_Lon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_esGeoIPLocation_Lat, kn) {
						currentKey = ffj_t_esGeoIPLocation_Lat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_esGeoIPLocation_Lat, kn) {
					currentKey = ffj_t_esGeoIPLocation_Lat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_esGeoIPLocation_Lon, kn) {
					currentKey = ffj_t_esGeoIPLocation_Lon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_esGeoIPLocationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_esGeoIPLocation_Lon:
					goto handle_Lon

				case ffj_t_esGeoIPLocation_Lat:
					goto handle_Lat

				case ffj_t_esGeoIPLocationno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Lon:

	/* handler: uj.Lon type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Lon = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.Lon = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lat:

	/* handler: uj.Lat type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Lat = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.Lat = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *nf) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *nf) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if mj.Ahespspi != nil {
		if true {
			buf.WriteString(`"ahesp.spi":`)
			fflib.FormatBits2(buf, uint64(*mj.Ahespspi), 10, *mj.Ahespspi < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Arpdaddrstr != nil {
		if true {
			buf.WriteString(`"arp.daddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Arpdaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Arpdhwaddr != nil {
		if true {
			buf.WriteString(`"arp.dhwaddr":`)
			fflib.FormatBits2(buf, uint64(*mj.Arpdhwaddr), 10, *mj.Arpdhwaddr < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Arphwtype != nil {
		if true {
			buf.WriteString(`"arp.hwtype":`)
			fflib.FormatBits2(buf, uint64(*mj.Arphwtype), 10, *mj.Arphwtype < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Arpoperation != nil {
		if true {
			buf.WriteString(`"arp.operation":`)
			fflib.FormatBits2(buf, uint64(*mj.Arpoperation), 10, *mj.Arpoperation < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Arpprotocoltype != nil {
		if true {
			buf.WriteString(`"arp.protocoltype":`)
			fflib.FormatBits2(buf, uint64(*mj.Arpprotocoltype), 10, *mj.Arpprotocoltype < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Arpsaddrstr != nil {
		if true {
			buf.WriteString(`"arp.saddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Arpsaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Arpshwaddr != nil {
		if true {
			buf.WriteString(`"arp.shwaddr":`)
			fflib.FormatBits2(buf, uint64(*mj.Arpshwaddr), 10, *mj.Arpshwaddr < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ctevent != nil {
		if true {
			buf.WriteString(`"ct.event":`)
			fflib.FormatBits2(buf, uint64(*mj.Ctevent), 10, *mj.Ctevent < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ctid != nil {
		if true {
			buf.WriteString(`"ct.id":`)
			fflib.FormatBits2(buf, uint64(*mj.Ctid), 10, *mj.Ctid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ctmark != nil {
		if true {
			buf.WriteString(`"ct.mark":`)
			fflib.FormatBits2(buf, uint64(*mj.Ctmark), 10, *mj.Ctmark < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Flowendsec != nil {
		if true {
			buf.WriteString(`"flow.end.sec":`)
			fflib.FormatBits2(buf, uint64(*mj.Flowendsec), 10, *mj.Flowendsec < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Flowendusec != nil {
		if true {
			buf.WriteString(`"flow.end.usec":`)
			fflib.FormatBits2(buf, uint64(*mj.Flowendusec), 10, *mj.Flowendusec < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Flowstartsec != nil {
		if true {
			buf.WriteString(`"flow.start.sec":`)
			fflib.FormatBits2(buf, uint64(*mj.Flowstartsec), 10, *mj.Flowstartsec < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Flowstartusec != nil {
		if true {
			buf.WriteString(`"flow.start.usec":`)
			fflib.FormatBits2(buf, uint64(*mj.Flowstartusec), 10, *mj.Flowstartusec < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpcode != nil {
		if true {
			buf.WriteString(`"icmp.code":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpcode), 10, *mj.Icmpcode < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpcsum != nil {
		if true {
			buf.WriteString(`"icmp.csum":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpcsum), 10, *mj.Icmpcsum < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpechoid != nil {
		if true {
			buf.WriteString(`"icmp.echoid":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpechoid), 10, *mj.Icmpechoid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpechoseq != nil {
		if true {
			buf.WriteString(`"icmp.echoseq":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpechoseq), 10, *mj.Icmpechoseq < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpfragmtu != nil {
		if true {
			buf.WriteString(`"icmp.fragmtu":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpfragmtu), 10, *mj.Icmpfragmtu < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpgateway != nil {
		if true {
			buf.WriteString(`"icmp.gateway":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpgateway), 10, *mj.Icmpgateway < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmptype != nil {
		if true {
			buf.WriteString(`"icmp.type":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmptype), 10, *mj.Icmptype < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpv6code != nil {
		if true {
			buf.WriteString(`"icmpv6.code":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpv6code), 10, *mj.Icmpv6code < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpv6csum != nil {
		if true {
			buf.WriteString(`"icmpv6.csum":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpv6csum), 10, *mj.Icmpv6csum < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpv6echoid != nil {
		if true {
			buf.WriteString(`"icmpv6.echoid":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpv6echoid), 10, *mj.Icmpv6echoid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpv6echoseq != nil {
		if true {
			buf.WriteString(`"icmpv6.echoseq":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpv6echoseq), 10, *mj.Icmpv6echoseq < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Icmpv6type != nil {
		if true {
			buf.WriteString(`"icmpv6.type":`)
			fflib.FormatBits2(buf, uint64(*mj.Icmpv6type), 10, *mj.Icmpv6type < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ip6flowlabel != nil {
		if true {
			buf.WriteString(`"ip6.flowlabel":`)
			fflib.FormatBits2(buf, uint64(*mj.Ip6flowlabel), 10, *mj.Ip6flowlabel < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ip6fragid != nil {
		if true {
			buf.WriteString(`"ip6.fragid":`)
			fflib.FormatBits2(buf, uint64(*mj.Ip6fragid), 10, *mj.Ip6fragid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ip6fragoff != nil {
		if true {
			buf.WriteString(`"ip6.fragoff":`)
			fflib.FormatBits2(buf, uint64(*mj.Ip6fragoff), 10, *mj.Ip6fragoff < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ip6hoplimit != nil {
		if true {
			buf.WriteString(`"ip6.hoplimit":`)
			fflib.FormatBits2(buf, uint64(*mj.Ip6hoplimit), 10, *mj.Ip6hoplimit < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ip6nexthdr != nil {
		if true {
			buf.WriteString(`"ip6.nexthdr":`)
			fflib.FormatBits2(buf, uint64(*mj.Ip6nexthdr), 10, *mj.Ip6nexthdr < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ip6payloadlen != nil {
		if true {
			buf.WriteString(`"ip6.payloadlen":`)
			fflib.FormatBits2(buf, uint64(*mj.Ip6payloadlen), 10, *mj.Ip6payloadlen < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ip6priority != nil {
		if true {
			buf.WriteString(`"ip6.priority":`)
			fflib.FormatBits2(buf, uint64(*mj.Ip6priority), 10, *mj.Ip6priority < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ipcsum != nil {
		if true {
			buf.WriteString(`"ip.csum":`)
			fflib.FormatBits2(buf, uint64(*mj.Ipcsum), 10, *mj.Ipcsum < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ipdaddrstr != nil {
		if true {
			buf.WriteString(`"ip.daddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Ipdaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Ipfragoff != nil {
		if true {
			buf.WriteString(`"ip.fragoff":`)
			fflib.FormatBits2(buf, uint64(*mj.Ipfragoff), 10, *mj.Ipfragoff < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ipid != nil {
		if true {
			buf.WriteString(`"ip.id":`)
			fflib.FormatBits2(buf, uint64(*mj.Ipid), 10, *mj.Ipid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ipihl != nil {
		if true {
			buf.WriteString(`"ip.ihl":`)
			fflib.FormatBits2(buf, uint64(*mj.Ipihl), 10, *mj.Ipihl < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ipprotocol != nil {
		if true {
			buf.WriteString(`"ip.protocol":`)
			fflib.FormatBits2(buf, uint64(*mj.Ipprotocol), 10, *mj.Ipprotocol < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ipsaddrstr != nil {
		if true {
			buf.WriteString(`"ip.saddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Ipsaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Iptos != nil {
		if true {
			buf.WriteString(`"ip.tos":`)
			fflib.FormatBits2(buf, uint64(*mj.Iptos), 10, *mj.Iptos < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Iptotlen != nil {
		if true {
			buf.WriteString(`"ip.totlen":`)
			fflib.FormatBits2(buf, uint64(*mj.Iptotlen), 10, *mj.Iptotlen < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Ipttl != nil {
		if true {
			buf.WriteString(`"ip.ttl":`)
			fflib.FormatBits2(buf, uint64(*mj.Ipttl), 10, *mj.Ipttl < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Macdaddrstr != nil {
		if true {
			buf.WriteString(`"mac.daddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Macdaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Macsaddrstr != nil {
		if true {
			buf.WriteString(`"mac.saddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Macsaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Macstr != nil {
		if true {
			buf.WriteString(`"mac.str":`)
			fflib.WriteJsonString(buf, string(*mj.Macstr))
			buf.WriteByte(',')
		}
	}
	if mj.Nufwappname != nil {
		if true {
			buf.WriteString(`"nufw.app.name":`)
			fflib.WriteJsonString(buf, string(*mj.Nufwappname))
			buf.WriteByte(',')
		}
	}
	if mj.Nufwosname != nil {
		if true {
			buf.WriteString(`"nufw.os.name":`)
			fflib.WriteJsonString(buf, string(*mj.Nufwosname))
			buf.WriteByte(',')
		}
	}
	if mj.Nufwosrel != nil {
		if true {
			buf.WriteString(`"nufw.os.rel":`)
			fflib.WriteJsonString(buf, string(*mj.Nufwosrel))
			buf.WriteByte(',')
		}
	}
	if mj.Nufwosvers != nil {
		if true {
			buf.WriteString(`"nufw.os.vers":`)
			fflib.WriteJsonString(buf, string(*mj.Nufwosvers))
			buf.WriteByte(',')
		}
	}
	if mj.Nufwuserid != nil {
		if true {
			buf.WriteString(`"nufw.user.id":`)
			fflib.FormatBits2(buf, uint64(*mj.Nufwuserid), 10, *mj.Nufwuserid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Nufwusername != nil {
		if true {
			buf.WriteString(`"nufw.user.name":`)
			fflib.WriteJsonString(buf, string(*mj.Nufwusername))
			buf.WriteByte(',')
		}
	}
	if mj.Oobfamily != nil {
		if true {
			buf.WriteString(`"oob.family":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobfamily), 10, *mj.Oobfamily < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobgid != nil {
		if true {
			buf.WriteString(`"oob.gid":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobgid), 10, *mj.Oobgid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobhook != nil {
		if true {
			buf.WriteString(`"oob.hook":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobhook), 10, *mj.Oobhook < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobifindexin != nil {
		if true {
			buf.WriteString(`"oob.ifindex_in":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobifindexin), 10, *mj.Oobifindexin < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobifindexout != nil {
		if true {
			buf.WriteString(`"oob.ifindex_out":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobifindexout), 10, *mj.Oobifindexout < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobin != nil {
		if true {
			buf.WriteString(`"oob.in":`)
			fflib.WriteJsonString(buf, string(*mj.Oobin))
			buf.WriteByte(',')
		}
	}
	if mj.Oobmark != nil {
		buf.WriteString(`"oob.mark":`)
		fflib.FormatBits2(buf, uint64(*mj.Oobmark), 10, *mj.Oobmark < 0)
	} else {
		buf.WriteString(`"oob.mark":null`)
	}
	buf.WriteByte(',')
	if mj.Oobout != nil {
		if true {
			buf.WriteString(`"oob.out":`)
			fflib.WriteJsonString(buf, string(*mj.Oobout))
			buf.WriteByte(',')
		}
	}
	if mj.Oobprefix != nil {
		if true {
			buf.WriteString(`"oob.prefix":`)
			fflib.WriteJsonString(buf, string(*mj.Oobprefix))
			buf.WriteByte(',')
		}
	}
	if mj.Oobprotocol != nil {
		if true {
			buf.WriteString(`"oob.protocol":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobprotocol), 10, *mj.Oobprotocol < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobseqglobal != nil {
		if true {
			buf.WriteString(`"oob.seq.global":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobseqglobal), 10, *mj.Oobseqglobal < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobseqlocal != nil {
		if true {
			buf.WriteString(`"oob.seq.local":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobseqlocal), 10, *mj.Oobseqlocal < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobtimesec != nil {
		if true {
			buf.WriteString(`"oob.time.sec":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobtimesec), 10, *mj.Oobtimesec < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobtimeusec != nil {
		if true {
			buf.WriteString(`"oob.time.usec":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobtimeusec), 10, *mj.Oobtimeusec < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Oobuid != nil {
		if true {
			buf.WriteString(`"oob.uid":`)
			fflib.FormatBits2(buf, uint64(*mj.Oobuid), 10, *mj.Oobuid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Origipdaddrstr != nil {
		if true {
			buf.WriteString(`"orig.ip.daddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Origipdaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Origipprotocol != nil {
		if true {
			buf.WriteString(`"orig.ip.protocol":`)
			fflib.FormatBits2(buf, uint64(*mj.Origipprotocol), 10, *mj.Origipprotocol < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Origipsaddrstr != nil {
		if true {
			buf.WriteString(`"orig.ip.saddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Origipsaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Origl4dport != nil {
		if true {
			buf.WriteString(`"orig.l4.dport":`)
			fflib.FormatBits2(buf, uint64(*mj.Origl4dport), 10, *mj.Origl4dport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Origl4sport != nil {
		if true {
			buf.WriteString(`"orig.l4.sport":`)
			fflib.FormatBits2(buf, uint64(*mj.Origl4sport), 10, *mj.Origl4sport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Origrawpktcount != nil {
		if true {
			buf.WriteString(`"orig.raw.pktcount":`)
			fflib.FormatBits2(buf, uint64(*mj.Origrawpktcount), 10, *mj.Origrawpktcount < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Origrawpktlen != nil {
		if true {
			buf.WriteString(`"orig.raw.pktlen":`)
			fflib.FormatBits2(buf, uint64(*mj.Origrawpktlen), 10, *mj.Origrawpktlen < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Print != nil {
		if true {
			buf.WriteString(`"print":`)
			fflib.WriteJsonString(buf, string(*mj.Print))
			buf.WriteByte(',')
		}
	}
	if mj.Pwsniffpass != nil {
		if true {
			buf.WriteString(`"pwsniff.pass":`)
			fflib.WriteJsonString(buf, string(*mj.Pwsniffpass))
			buf.WriteByte(',')
		}
	}
	if mj.Pwsniffuser != nil {
		if true {
			buf.WriteString(`"pwsniff.user":`)
			fflib.WriteJsonString(buf, string(*mj.Pwsniffuser))
			buf.WriteByte(',')
		}
	}
	if mj.Rawlabel != nil {
		if true {
			buf.WriteString(`"raw.label":`)
			fflib.FormatBits2(buf, uint64(*mj.Rawlabel), 10, *mj.Rawlabel < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Rawmacaddrlen != nil {
		if true {
			buf.WriteString(`"raw.mac.addrlen":`)
			fflib.FormatBits2(buf, uint64(*mj.Rawmacaddrlen), 10, *mj.Rawmacaddrlen < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Rawmac != nil {
		if true {
			buf.WriteString(`"raw.mac":`)
			fflib.FormatBits2(buf, uint64(*mj.Rawmac), 10, *mj.Rawmac < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Rawmaclen != nil {
		if true {
			buf.WriteString(`"raw.mac_len":`)
			fflib.FormatBits2(buf, uint64(*mj.Rawmaclen), 10, *mj.Rawmaclen < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Rawpktcount != nil {
		if true {
			buf.WriteString(`"raw.pktcount":`)
			fflib.FormatBits2(buf, uint64(*mj.Rawpktcount), 10, *mj.Rawpktcount < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Rawpkt != nil {
		if true {
			buf.WriteString(`"raw.pkt":`)
			fflib.FormatBits2(buf, uint64(*mj.Rawpkt), 10, *mj.Rawpkt < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Rawpktlen != nil {
		if true {
			buf.WriteString(`"raw.pktlen":`)
			fflib.FormatBits2(buf, uint64(*mj.Rawpktlen), 10, *mj.Rawpktlen < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Rawtype != nil {
		if true {
			buf.WriteString(`"raw.type":`)
			fflib.FormatBits2(buf, uint64(*mj.Rawtype), 10, *mj.Rawtype < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Replyipdaddrstr != nil {
		if true {
			buf.WriteString(`"reply.ip.daddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Replyipdaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Replyipprotocol != nil {
		if true {
			buf.WriteString(`"reply.ip.protocol":`)
			fflib.FormatBits2(buf, uint64(*mj.Replyipprotocol), 10, *mj.Replyipprotocol < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Replyipsaddrstr != nil {
		if true {
			buf.WriteString(`"reply.ip.saddr.str":`)
			fflib.WriteJsonString(buf, string(*mj.Replyipsaddrstr))
			buf.WriteByte(',')
		}
	}
	if mj.Replyl4dport != nil {
		if true {
			buf.WriteString(`"reply.l4.dport":`)
			fflib.FormatBits2(buf, uint64(*mj.Replyl4dport), 10, *mj.Replyl4dport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Replyl4sport != nil {
		if true {
			buf.WriteString(`"reply.l4.sport":`)
			fflib.FormatBits2(buf, uint64(*mj.Replyl4sport), 10, *mj.Replyl4sport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Replyrawpktcount != nil {
		if true {
			buf.WriteString(`"reply.raw.pktcount":`)
			fflib.FormatBits2(buf, uint64(*mj.Replyrawpktcount), 10, *mj.Replyrawpktcount < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Replyrawpktlen != nil {
		if true {
			buf.WriteString(`"reply.raw.pktlen":`)
			fflib.FormatBits2(buf, uint64(*mj.Replyrawpktlen), 10, *mj.Replyrawpktlen < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Sctpcsum != nil {
		if true {
			buf.WriteString(`"sctp.csum":`)
			fflib.FormatBits2(buf, uint64(*mj.Sctpcsum), 10, *mj.Sctpcsum < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Sctpdport != nil {
		if true {
			buf.WriteString(`"sctp.dport":`)
			fflib.FormatBits2(buf, uint64(*mj.Sctpdport), 10, *mj.Sctpdport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Sctpsport != nil {
		if true {
			buf.WriteString(`"sctp.sport":`)
			fflib.FormatBits2(buf, uint64(*mj.Sctpsport), 10, *mj.Sctpsport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Sumbytes != nil {
		if true {
			buf.WriteString(`"sum.bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.Sumbytes), 10, *mj.Sumbytes < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Sumname != nil {
		if true {
			buf.WriteString(`"sum.name":`)
			fflib.WriteJsonString(buf, string(*mj.Sumname))
			buf.WriteByte(',')
		}
	}
	if mj.Sumpkts != nil {
		if true {
			buf.WriteString(`"sum.pkts":`)
			fflib.FormatBits2(buf, uint64(*mj.Sumpkts), 10, *mj.Sumpkts < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpack != nil {
		if true {
			buf.WriteString(`"tcp.ack":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpack), 10, *mj.Tcpack < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpackseq != nil {
		if true {
			buf.WriteString(`"tcp.ackseq":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpackseq), 10, *mj.Tcpackseq < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpcsum != nil {
		if true {
			buf.WriteString(`"tcp.csum":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpcsum), 10, *mj.Tcpcsum < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpdport != nil {
		if true {
			buf.WriteString(`"tcp.dport":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpdport), 10, *mj.Tcpdport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpfin != nil {
		if true {
			buf.WriteString(`"tcp.fin":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpfin), 10, *mj.Tcpfin < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpoffset != nil {
		if true {
			buf.WriteString(`"tcp.offset":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpoffset), 10, *mj.Tcpoffset < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcppsh != nil {
		if true {
			buf.WriteString(`"tcp.psh":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcppsh), 10, *mj.Tcppsh < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpreserved != nil {
		if true {
			buf.WriteString(`"tcp.reserved":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpreserved), 10, *mj.Tcpreserved < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpres1 != nil {
		if true {
			buf.WriteString(`"tcp.res1":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpres1), 10, *mj.Tcpres1 < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpres2 != nil {
		if true {
			buf.WriteString(`"tcp.res2":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpres2), 10, *mj.Tcpres2 < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcprst != nil {
		if true {
			buf.WriteString(`"tcp.rst":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcprst), 10, *mj.Tcprst < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpseq != nil {
		if true {
			buf.WriteString(`"tcp.seq":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpseq), 10, *mj.Tcpseq < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpsport != nil {
		if true {
			buf.WriteString(`"tcp.sport":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpsport), 10, *mj.Tcpsport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpsyn != nil {
		if true {
			buf.WriteString(`"tcp.syn":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpsyn), 10, *mj.Tcpsyn < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpurg != nil {
		if true {
			buf.WriteString(`"tcp.urg":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpurg), 10, *mj.Tcpurg < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpurgp != nil {
		if true {
			buf.WriteString(`"tcp.urgp":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpurgp), 10, *mj.Tcpurgp < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Tcpwindow != nil {
		if true {
			buf.WriteString(`"tcp.window":`)
			fflib.FormatBits2(buf, uint64(*mj.Tcpwindow), 10, *mj.Tcpwindow < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Udpcsum != nil {
		if true {
			buf.WriteString(`"udp.csum":`)
			fflib.FormatBits2(buf, uint64(*mj.Udpcsum), 10, *mj.Udpcsum < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Udpdport != nil {
		if true {
			buf.WriteString(`"udp.dport":`)
			fflib.FormatBits2(buf, uint64(*mj.Udpdport), 10, *mj.Udpdport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Udplen != nil {
		if true {
			buf.WriteString(`"udp.len":`)
			fflib.FormatBits2(buf, uint64(*mj.Udplen), 10, *mj.Udplen < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Udpsport != nil {
		if true {
			buf.WriteString(`"udp.sport":`)
			fflib.FormatBits2(buf, uint64(*mj.Udpsport), 10, *mj.Udpsport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Srcport != nil {
		if true {
			buf.WriteString(`"src_port":`)
			fflib.FormatBits2(buf, uint64(*mj.Srcport), 10, *mj.Srcport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Srcip != nil {
		if true {
			buf.WriteString(`"src_ip":`)
			fflib.WriteJsonString(buf, string(*mj.Srcip))
			buf.WriteByte(',')
		}
	}
	if mj.Destport != nil {
		if true {
			buf.WriteString(`"dest_port":`)
			fflib.FormatBits2(buf, uint64(*mj.Destport), 10, *mj.Destport < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Destip != nil {
		if true {
			buf.WriteString(`"dest_ip":`)
			fflib.WriteJsonString(buf, string(*mj.Destip))
			buf.WriteByte(',')
		}
	}
	if mj.Dvc != nil {
		if true {
			buf.WriteString(`"dvc":`)
			fflib.WriteJsonString(buf, string(*mj.Dvc))
			buf.WriteByte(',')
		}
	}
	if mj.Timestamp != nil {
		if true {
			buf.WriteString(`"timestamp":`)
			fflib.WriteJsonString(buf, string(*mj.Timestamp))
			buf.WriteByte(',')
		}
	}
	if len(mj.Ltimestamp) != 0 {
		buf.WriteString(`"@timestamp":`)
		fflib.WriteJsonString(buf, string(mj.Ltimestamp))
		buf.WriteByte(',')
	}
	if mj.Action != nil {
		if true {
			buf.WriteString(`"action":`)
			fflib.WriteJsonString(buf, string(*mj.Action))
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"geoip":`)

	{

		err = mj.GeoIP.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_nfbase = iota
	ffj_t_nfno_such_key

	ffj_t_nf_Ahespspi

	ffj_t_nf_Arpdaddrstr

	ffj_t_nf_Arpdhwaddr

	ffj_t_nf_Arphwtype

	ffj_t_nf_Arpoperation

	ffj_t_nf_Arpprotocoltype

	ffj_t_nf_Arpsaddrstr

	ffj_t_nf_Arpshwaddr

	ffj_t_nf_Ctevent

	ffj_t_nf_Ctid

	ffj_t_nf_Ctmark

	ffj_t_nf_Flowendsec

	ffj_t_nf_Flowendusec

	ffj_t_nf_Flowstartsec

	ffj_t_nf_Flowstartusec

	ffj_t_nf_Icmpcode

	ffj_t_nf_Icmpcsum

	ffj_t_nf_Icmpechoid

	ffj_t_nf_Icmpechoseq

	ffj_t_nf_Icmpfragmtu

	ffj_t_nf_Icmpgateway

	ffj_t_nf_Icmptype

	ffj_t_nf_Icmpv6code

	ffj_t_nf_Icmpv6csum

	ffj_t_nf_Icmpv6echoid

	ffj_t_nf_Icmpv6echoseq

	ffj_t_nf_Icmpv6type

	ffj_t_nf_Ip6flowlabel

	ffj_t_nf_Ip6fragid

	ffj_t_nf_Ip6fragoff

	ffj_t_nf_Ip6hoplimit

	ffj_t_nf_Ip6nexthdr

	ffj_t_nf_Ip6payloadlen

	ffj_t_nf_Ip6priority

	ffj_t_nf_Ipcsum

	ffj_t_nf_Ipdaddrstr

	ffj_t_nf_Ipfragoff

	ffj_t_nf_Ipid

	ffj_t_nf_Ipihl

	ffj_t_nf_Ipprotocol

	ffj_t_nf_Ipsaddrstr

	ffj_t_nf_Iptos

	ffj_t_nf_Iptotlen

	ffj_t_nf_Ipttl

	ffj_t_nf_Macdaddrstr

	ffj_t_nf_Macsaddrstr

	ffj_t_nf_Macstr

	ffj_t_nf_Nufwappname

	ffj_t_nf_Nufwosname

	ffj_t_nf_Nufwosrel

	ffj_t_nf_Nufwosvers

	ffj_t_nf_Nufwuserid

	ffj_t_nf_Nufwusername

	ffj_t_nf_Oobfamily

	ffj_t_nf_Oobgid

	ffj_t_nf_Oobhook

	ffj_t_nf_Oobifindexin

	ffj_t_nf_Oobifindexout

	ffj_t_nf_Oobin

	ffj_t_nf_Oobmark

	ffj_t_nf_Oobout

	ffj_t_nf_Oobprefix

	ffj_t_nf_Oobprotocol

	ffj_t_nf_Oobseqglobal

	ffj_t_nf_Oobseqlocal

	ffj_t_nf_Oobtimesec

	ffj_t_nf_Oobtimeusec

	ffj_t_nf_Oobuid

	ffj_t_nf_Origipdaddrstr

	ffj_t_nf_Origipprotocol

	ffj_t_nf_Origipsaddrstr

	ffj_t_nf_Origl4dport

	ffj_t_nf_Origl4sport

	ffj_t_nf_Origrawpktcount

	ffj_t_nf_Origrawpktlen

	ffj_t_nf_Print

	ffj_t_nf_Pwsniffpass

	ffj_t_nf_Pwsniffuser

	ffj_t_nf_Rawlabel

	ffj_t_nf_Rawmacaddrlen

	ffj_t_nf_Rawmac

	ffj_t_nf_Rawmaclen

	ffj_t_nf_Rawpktcount

	ffj_t_nf_Rawpkt

	ffj_t_nf_Rawpktlen

	ffj_t_nf_Rawtype

	ffj_t_nf_Replyipdaddrstr

	ffj_t_nf_Replyipprotocol

	ffj_t_nf_Replyipsaddrstr

	ffj_t_nf_Replyl4dport

	ffj_t_nf_Replyl4sport

	ffj_t_nf_Replyrawpktcount

	ffj_t_nf_Replyrawpktlen

	ffj_t_nf_Sctpcsum

	ffj_t_nf_Sctpdport

	ffj_t_nf_Sctpsport

	ffj_t_nf_Sumbytes

	ffj_t_nf_Sumname

	ffj_t_nf_Sumpkts

	ffj_t_nf_Tcpack

	ffj_t_nf_Tcpackseq

	ffj_t_nf_Tcpcsum

	ffj_t_nf_Tcpdport

	ffj_t_nf_Tcpfin

	ffj_t_nf_Tcpoffset

	ffj_t_nf_Tcppsh

	ffj_t_nf_Tcpreserved

	ffj_t_nf_Tcpres1

	ffj_t_nf_Tcpres2

	ffj_t_nf_Tcprst

	ffj_t_nf_Tcpseq

	ffj_t_nf_Tcpsport

	ffj_t_nf_Tcpsyn

	ffj_t_nf_Tcpurg

	ffj_t_nf_Tcpurgp

	ffj_t_nf_Tcpwindow

	ffj_t_nf_Udpcsum

	ffj_t_nf_Udpdport

	ffj_t_nf_Udplen

	ffj_t_nf_Udpsport

	ffj_t_nf_Srcport

	ffj_t_nf_Srcip

	ffj_t_nf_Destport

	ffj_t_nf_Destip

	ffj_t_nf_Dvc

	ffj_t_nf_Timestamp

	ffj_t_nf_Ltimestamp

	ffj_t_nf_Action

	ffj_t_nf_GeoIP
)

var ffj_key_nf_Ahespspi = []byte("ahesp.spi")

var ffj_key_nf_Arpdaddrstr = []byte("arp.daddr.str")

var ffj_key_nf_Arpdhwaddr = []byte("arp.dhwaddr")

var ffj_key_nf_Arphwtype = []byte("arp.hwtype")

var ffj_key_nf_Arpoperation = []byte("arp.operation")

var ffj_key_nf_Arpprotocoltype = []byte("arp.protocoltype")

var ffj_key_nf_Arpsaddrstr = []byte("arp.saddr.str")

var ffj_key_nf_Arpshwaddr = []byte("arp.shwaddr")

var ffj_key_nf_Ctevent = []byte("ct.event")

var ffj_key_nf_Ctid = []byte("ct.id")

var ffj_key_nf_Ctmark = []byte("ct.mark")

var ffj_key_nf_Flowendsec = []byte("flow.end.sec")

var ffj_key_nf_Flowendusec = []byte("flow.end.usec")

var ffj_key_nf_Flowstartsec = []byte("flow.start.sec")

var ffj_key_nf_Flowstartusec = []byte("flow.start.usec")

var ffj_key_nf_Icmpcode = []byte("icmp.code")

var ffj_key_nf_Icmpcsum = []byte("icmp.csum")

var ffj_key_nf_Icmpechoid = []byte("icmp.echoid")

var ffj_key_nf_Icmpechoseq = []byte("icmp.echoseq")

var ffj_key_nf_Icmpfragmtu = []byte("icmp.fragmtu")

var ffj_key_nf_Icmpgateway = []byte("icmp.gateway")

var ffj_key_nf_Icmptype = []byte("icmp.type")

var ffj_key_nf_Icmpv6code = []byte("icmpv6.code")

var ffj_key_nf_Icmpv6csum = []byte("icmpv6.csum")

var ffj_key_nf_Icmpv6echoid = []byte("icmpv6.echoid")

var ffj_key_nf_Icmpv6echoseq = []byte("icmpv6.echoseq")

var ffj_key_nf_Icmpv6type = []byte("icmpv6.type")

var ffj_key_nf_Ip6flowlabel = []byte("ip6.flowlabel")

var ffj_key_nf_Ip6fragid = []byte("ip6.fragid")

var ffj_key_nf_Ip6fragoff = []byte("ip6.fragoff")

var ffj_key_nf_Ip6hoplimit = []byte("ip6.hoplimit")

var ffj_key_nf_Ip6nexthdr = []byte("ip6.nexthdr")

var ffj_key_nf_Ip6payloadlen = []byte("ip6.payloadlen")

var ffj_key_nf_Ip6priority = []byte("ip6.priority")

var ffj_key_nf_Ipcsum = []byte("ip.csum")

var ffj_key_nf_Ipdaddrstr = []byte("ip.daddr.str")

var ffj_key_nf_Ipfragoff = []byte("ip.fragoff")

var ffj_key_nf_Ipid = []byte("ip.id")

var ffj_key_nf_Ipihl = []byte("ip.ihl")

var ffj_key_nf_Ipprotocol = []byte("ip.protocol")

var ffj_key_nf_Ipsaddrstr = []byte("ip.saddr.str")

var ffj_key_nf_Iptos = []byte("ip.tos")

var ffj_key_nf_Iptotlen = []byte("ip.totlen")

var ffj_key_nf_Ipttl = []byte("ip.ttl")

var ffj_key_nf_Macdaddrstr = []byte("mac.daddr.str")

var ffj_key_nf_Macsaddrstr = []byte("mac.saddr.str")

var ffj_key_nf_Macstr = []byte("mac.str")

var ffj_key_nf_Nufwappname = []byte("nufw.app.name")

var ffj_key_nf_Nufwosname = []byte("nufw.os.name")

var ffj_key_nf_Nufwosrel = []byte("nufw.os.rel")

var ffj_key_nf_Nufwosvers = []byte("nufw.os.vers")

var ffj_key_nf_Nufwuserid = []byte("nufw.user.id")

var ffj_key_nf_Nufwusername = []byte("nufw.user.name")

var ffj_key_nf_Oobfamily = []byte("oob.family")

var ffj_key_nf_Oobgid = []byte("oob.gid")

var ffj_key_nf_Oobhook = []byte("oob.hook")

var ffj_key_nf_Oobifindexin = []byte("oob.ifindex_in")

var ffj_key_nf_Oobifindexout = []byte("oob.ifindex_out")

var ffj_key_nf_Oobin = []byte("oob.in")

var ffj_key_nf_Oobmark = []byte("oob.mark")

var ffj_key_nf_Oobout = []byte("oob.out")

var ffj_key_nf_Oobprefix = []byte("oob.prefix")

var ffj_key_nf_Oobprotocol = []byte("oob.protocol")

var ffj_key_nf_Oobseqglobal = []byte("oob.seq.global")

var ffj_key_nf_Oobseqlocal = []byte("oob.seq.local")

var ffj_key_nf_Oobtimesec = []byte("oob.time.sec")

var ffj_key_nf_Oobtimeusec = []byte("oob.time.usec")

var ffj_key_nf_Oobuid = []byte("oob.uid")

var ffj_key_nf_Origipdaddrstr = []byte("orig.ip.daddr.str")

var ffj_key_nf_Origipprotocol = []byte("orig.ip.protocol")

var ffj_key_nf_Origipsaddrstr = []byte("orig.ip.saddr.str")

var ffj_key_nf_Origl4dport = []byte("orig.l4.dport")

var ffj_key_nf_Origl4sport = []byte("orig.l4.sport")

var ffj_key_nf_Origrawpktcount = []byte("orig.raw.pktcount")

var ffj_key_nf_Origrawpktlen = []byte("orig.raw.pktlen")

var ffj_key_nf_Print = []byte("print")

var ffj_key_nf_Pwsniffpass = []byte("pwsniff.pass")

var ffj_key_nf_Pwsniffuser = []byte("pwsniff.user")

var ffj_key_nf_Rawlabel = []byte("raw.label")

var ffj_key_nf_Rawmacaddrlen = []byte("raw.mac.addrlen")

var ffj_key_nf_Rawmac = []byte("raw.mac")

var ffj_key_nf_Rawmaclen = []byte("raw.mac_len")

var ffj_key_nf_Rawpktcount = []byte("raw.pktcount")

var ffj_key_nf_Rawpkt = []byte("raw.pkt")

var ffj_key_nf_Rawpktlen = []byte("raw.pktlen")

var ffj_key_nf_Rawtype = []byte("raw.type")

var ffj_key_nf_Replyipdaddrstr = []byte("reply.ip.daddr.str")

var ffj_key_nf_Replyipprotocol = []byte("reply.ip.protocol")

var ffj_key_nf_Replyipsaddrstr = []byte("reply.ip.saddr.str")

var ffj_key_nf_Replyl4dport = []byte("reply.l4.dport")

var ffj_key_nf_Replyl4sport = []byte("reply.l4.sport")

var ffj_key_nf_Replyrawpktcount = []byte("reply.raw.pktcount")

var ffj_key_nf_Replyrawpktlen = []byte("reply.raw.pktlen")

var ffj_key_nf_Sctpcsum = []byte("sctp.csum")

var ffj_key_nf_Sctpdport = []byte("sctp.dport")

var ffj_key_nf_Sctpsport = []byte("sctp.sport")

var ffj_key_nf_Sumbytes = []byte("sum.bytes")

var ffj_key_nf_Sumname = []byte("sum.name")

var ffj_key_nf_Sumpkts = []byte("sum.pkts")

var ffj_key_nf_Tcpack = []byte("tcp.ack")

var ffj_key_nf_Tcpackseq = []byte("tcp.ackseq")

var ffj_key_nf_Tcpcsum = []byte("tcp.csum")

var ffj_key_nf_Tcpdport = []byte("tcp.dport")

var ffj_key_nf_Tcpfin = []byte("tcp.fin")

var ffj_key_nf_Tcpoffset = []byte("tcp.offset")

var ffj_key_nf_Tcppsh = []byte("tcp.psh")

var ffj_key_nf_Tcpreserved = []byte("tcp.reserved")

var ffj_key_nf_Tcpres1 = []byte("tcp.res1")

var ffj_key_nf_Tcpres2 = []byte("tcp.res2")

var ffj_key_nf_Tcprst = []byte("tcp.rst")

var ffj_key_nf_Tcpseq = []byte("tcp.seq")

var ffj_key_nf_Tcpsport = []byte("tcp.sport")

var ffj_key_nf_Tcpsyn = []byte("tcp.syn")

var ffj_key_nf_Tcpurg = []byte("tcp.urg")

var ffj_key_nf_Tcpurgp = []byte("tcp.urgp")

var ffj_key_nf_Tcpwindow = []byte("tcp.window")

var ffj_key_nf_Udpcsum = []byte("udp.csum")

var ffj_key_nf_Udpdport = []byte("udp.dport")

var ffj_key_nf_Udplen = []byte("udp.len")

var ffj_key_nf_Udpsport = []byte("udp.sport")

var ffj_key_nf_Srcport = []byte("src_port")

var ffj_key_nf_Srcip = []byte("src_ip")

var ffj_key_nf_Destport = []byte("dest_port")

var ffj_key_nf_Destip = []byte("dest_ip")

var ffj_key_nf_Dvc = []byte("dvc")

var ffj_key_nf_Timestamp = []byte("timestamp")

var ffj_key_nf_Ltimestamp = []byte("@timestamp")

var ffj_key_nf_Action = []byte("action")

var ffj_key_nf_GeoIP = []byte("geoip")

func (uj *nf) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *nf) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_nfbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_nfno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case '@':

					if bytes.Equal(ffj_key_nf_Ltimestamp, kn) {
						currentKey = ffj_t_nf_Ltimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'a':

					if bytes.Equal(ffj_key_nf_Ahespspi, kn) {
						currentKey = ffj_t_nf_Ahespspi
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Arpdaddrstr, kn) {
						currentKey = ffj_t_nf_Arpdaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Arpdhwaddr, kn) {
						currentKey = ffj_t_nf_Arpdhwaddr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Arphwtype, kn) {
						currentKey = ffj_t_nf_Arphwtype
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Arpoperation, kn) {
						currentKey = ffj_t_nf_Arpoperation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Arpprotocoltype, kn) {
						currentKey = ffj_t_nf_Arpprotocoltype
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Arpsaddrstr, kn) {
						currentKey = ffj_t_nf_Arpsaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Arpshwaddr, kn) {
						currentKey = ffj_t_nf_Arpshwaddr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Action, kn) {
						currentKey = ffj_t_nf_Action
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_nf_Ctevent, kn) {
						currentKey = ffj_t_nf_Ctevent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ctid, kn) {
						currentKey = ffj_t_nf_Ctid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ctmark, kn) {
						currentKey = ffj_t_nf_Ctmark
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_nf_Destport, kn) {
						currentKey = ffj_t_nf_Destport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Destip, kn) {
						currentKey = ffj_t_nf_Destip
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Dvc, kn) {
						currentKey = ffj_t_nf_Dvc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_nf_Flowendsec, kn) {
						currentKey = ffj_t_nf_Flowendsec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Flowendusec, kn) {
						currentKey = ffj_t_nf_Flowendusec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Flowstartsec, kn) {
						currentKey = ffj_t_nf_Flowstartsec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Flowstartusec, kn) {
						currentKey = ffj_t_nf_Flowstartusec
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_nf_GeoIP, kn) {
						currentKey = ffj_t_nf_GeoIP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_nf_Icmpcode, kn) {
						currentKey = ffj_t_nf_Icmpcode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpcsum, kn) {
						currentKey = ffj_t_nf_Icmpcsum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpechoid, kn) {
						currentKey = ffj_t_nf_Icmpechoid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpechoseq, kn) {
						currentKey = ffj_t_nf_Icmpechoseq
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpfragmtu, kn) {
						currentKey = ffj_t_nf_Icmpfragmtu
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpgateway, kn) {
						currentKey = ffj_t_nf_Icmpgateway
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmptype, kn) {
						currentKey = ffj_t_nf_Icmptype
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpv6code, kn) {
						currentKey = ffj_t_nf_Icmpv6code
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpv6csum, kn) {
						currentKey = ffj_t_nf_Icmpv6csum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpv6echoid, kn) {
						currentKey = ffj_t_nf_Icmpv6echoid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpv6echoseq, kn) {
						currentKey = ffj_t_nf_Icmpv6echoseq
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Icmpv6type, kn) {
						currentKey = ffj_t_nf_Icmpv6type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ip6flowlabel, kn) {
						currentKey = ffj_t_nf_Ip6flowlabel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ip6fragid, kn) {
						currentKey = ffj_t_nf_Ip6fragid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ip6fragoff, kn) {
						currentKey = ffj_t_nf_Ip6fragoff
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ip6hoplimit, kn) {
						currentKey = ffj_t_nf_Ip6hoplimit
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ip6nexthdr, kn) {
						currentKey = ffj_t_nf_Ip6nexthdr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ip6payloadlen, kn) {
						currentKey = ffj_t_nf_Ip6payloadlen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ip6priority, kn) {
						currentKey = ffj_t_nf_Ip6priority
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ipcsum, kn) {
						currentKey = ffj_t_nf_Ipcsum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ipdaddrstr, kn) {
						currentKey = ffj_t_nf_Ipdaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ipfragoff, kn) {
						currentKey = ffj_t_nf_Ipfragoff
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ipid, kn) {
						currentKey = ffj_t_nf_Ipid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ipihl, kn) {
						currentKey = ffj_t_nf_Ipihl
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ipprotocol, kn) {
						currentKey = ffj_t_nf_Ipprotocol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ipsaddrstr, kn) {
						currentKey = ffj_t_nf_Ipsaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Iptos, kn) {
						currentKey = ffj_t_nf_Iptos
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Iptotlen, kn) {
						currentKey = ffj_t_nf_Iptotlen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Ipttl, kn) {
						currentKey = ffj_t_nf_Ipttl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_nf_Macdaddrstr, kn) {
						currentKey = ffj_t_nf_Macdaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Macsaddrstr, kn) {
						currentKey = ffj_t_nf_Macsaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Macstr, kn) {
						currentKey = ffj_t_nf_Macstr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_nf_Nufwappname, kn) {
						currentKey = ffj_t_nf_Nufwappname
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Nufwosname, kn) {
						currentKey = ffj_t_nf_Nufwosname
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Nufwosrel, kn) {
						currentKey = ffj_t_nf_Nufwosrel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Nufwosvers, kn) {
						currentKey = ffj_t_nf_Nufwosvers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Nufwuserid, kn) {
						currentKey = ffj_t_nf_Nufwuserid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Nufwusername, kn) {
						currentKey = ffj_t_nf_Nufwusername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_nf_Oobfamily, kn) {
						currentKey = ffj_t_nf_Oobfamily
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobgid, kn) {
						currentKey = ffj_t_nf_Oobgid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobhook, kn) {
						currentKey = ffj_t_nf_Oobhook
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobifindexin, kn) {
						currentKey = ffj_t_nf_Oobifindexin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobifindexout, kn) {
						currentKey = ffj_t_nf_Oobifindexout
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobin, kn) {
						currentKey = ffj_t_nf_Oobin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobmark, kn) {
						currentKey = ffj_t_nf_Oobmark
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobout, kn) {
						currentKey = ffj_t_nf_Oobout
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobprefix, kn) {
						currentKey = ffj_t_nf_Oobprefix
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobprotocol, kn) {
						currentKey = ffj_t_nf_Oobprotocol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobseqglobal, kn) {
						currentKey = ffj_t_nf_Oobseqglobal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobseqlocal, kn) {
						currentKey = ffj_t_nf_Oobseqlocal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobtimesec, kn) {
						currentKey = ffj_t_nf_Oobtimesec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobtimeusec, kn) {
						currentKey = ffj_t_nf_Oobtimeusec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Oobuid, kn) {
						currentKey = ffj_t_nf_Oobuid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Origipdaddrstr, kn) {
						currentKey = ffj_t_nf_Origipdaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Origipprotocol, kn) {
						currentKey = ffj_t_nf_Origipprotocol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Origipsaddrstr, kn) {
						currentKey = ffj_t_nf_Origipsaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Origl4dport, kn) {
						currentKey = ffj_t_nf_Origl4dport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Origl4sport, kn) {
						currentKey = ffj_t_nf_Origl4sport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Origrawpktcount, kn) {
						currentKey = ffj_t_nf_Origrawpktcount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Origrawpktlen, kn) {
						currentKey = ffj_t_nf_Origrawpktlen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_nf_Print, kn) {
						currentKey = ffj_t_nf_Print
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Pwsniffpass, kn) {
						currentKey = ffj_t_nf_Pwsniffpass
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Pwsniffuser, kn) {
						currentKey = ffj_t_nf_Pwsniffuser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_nf_Rawlabel, kn) {
						currentKey = ffj_t_nf_Rawlabel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Rawmacaddrlen, kn) {
						currentKey = ffj_t_nf_Rawmacaddrlen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Rawmac, kn) {
						currentKey = ffj_t_nf_Rawmac
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Rawmaclen, kn) {
						currentKey = ffj_t_nf_Rawmaclen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Rawpktcount, kn) {
						currentKey = ffj_t_nf_Rawpktcount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Rawpkt, kn) {
						currentKey = ffj_t_nf_Rawpkt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Rawpktlen, kn) {
						currentKey = ffj_t_nf_Rawpktlen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Rawtype, kn) {
						currentKey = ffj_t_nf_Rawtype
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Replyipdaddrstr, kn) {
						currentKey = ffj_t_nf_Replyipdaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Replyipprotocol, kn) {
						currentKey = ffj_t_nf_Replyipprotocol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Replyipsaddrstr, kn) {
						currentKey = ffj_t_nf_Replyipsaddrstr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Replyl4dport, kn) {
						currentKey = ffj_t_nf_Replyl4dport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Replyl4sport, kn) {
						currentKey = ffj_t_nf_Replyl4sport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Replyrawpktcount, kn) {
						currentKey = ffj_t_nf_Replyrawpktcount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Replyrawpktlen, kn) {
						currentKey = ffj_t_nf_Replyrawpktlen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_nf_Sctpcsum, kn) {
						currentKey = ffj_t_nf_Sctpcsum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Sctpdport, kn) {
						currentKey = ffj_t_nf_Sctpdport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Sctpsport, kn) {
						currentKey = ffj_t_nf_Sctpsport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Sumbytes, kn) {
						currentKey = ffj_t_nf_Sumbytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Sumname, kn) {
						currentKey = ffj_t_nf_Sumname
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Sumpkts, kn) {
						currentKey = ffj_t_nf_Sumpkts
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Srcport, kn) {
						currentKey = ffj_t_nf_Srcport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Srcip, kn) {
						currentKey = ffj_t_nf_Srcip
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_nf_Tcpack, kn) {
						currentKey = ffj_t_nf_Tcpack
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpackseq, kn) {
						currentKey = ffj_t_nf_Tcpackseq
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpcsum, kn) {
						currentKey = ffj_t_nf_Tcpcsum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpdport, kn) {
						currentKey = ffj_t_nf_Tcpdport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpfin, kn) {
						currentKey = ffj_t_nf_Tcpfin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpoffset, kn) {
						currentKey = ffj_t_nf_Tcpoffset
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcppsh, kn) {
						currentKey = ffj_t_nf_Tcppsh
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpreserved, kn) {
						currentKey = ffj_t_nf_Tcpreserved
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpres1, kn) {
						currentKey = ffj_t_nf_Tcpres1
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpres2, kn) {
						currentKey = ffj_t_nf_Tcpres2
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcprst, kn) {
						currentKey = ffj_t_nf_Tcprst
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpseq, kn) {
						currentKey = ffj_t_nf_Tcpseq
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpsport, kn) {
						currentKey = ffj_t_nf_Tcpsport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpsyn, kn) {
						currentKey = ffj_t_nf_Tcpsyn
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpurg, kn) {
						currentKey = ffj_t_nf_Tcpurg
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpurgp, kn) {
						currentKey = ffj_t_nf_Tcpurgp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Tcpwindow, kn) {
						currentKey = ffj_t_nf_Tcpwindow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Timestamp, kn) {
						currentKey = ffj_t_nf_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_nf_Udpcsum, kn) {
						currentKey = ffj_t_nf_Udpcsum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Udpdport, kn) {
						currentKey = ffj_t_nf_Udpdport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Udplen, kn) {
						currentKey = ffj_t_nf_Udplen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_nf_Udpsport, kn) {
						currentKey = ffj_t_nf_Udpsport
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_nf_GeoIP, kn) {
					currentKey = ffj_t_nf_GeoIP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_nf_Action, kn) {
					currentKey = ffj_t_nf_Action
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Ltimestamp, kn) {
					currentKey = ffj_t_nf_Ltimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Timestamp, kn) {
					currentKey = ffj_t_nf_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_nf_Dvc, kn) {
					currentKey = ffj_t_nf_Dvc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Destip, kn) {
					currentKey = ffj_t_nf_Destip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Destport, kn) {
					currentKey = ffj_t_nf_Destport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Srcip, kn) {
					currentKey = ffj_t_nf_Srcip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Srcport, kn) {
					currentKey = ffj_t_nf_Srcport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Udpsport, kn) {
					currentKey = ffj_t_nf_Udpsport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Udplen, kn) {
					currentKey = ffj_t_nf_Udplen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Udpdport, kn) {
					currentKey = ffj_t_nf_Udpdport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Udpcsum, kn) {
					currentKey = ffj_t_nf_Udpcsum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Tcpwindow, kn) {
					currentKey = ffj_t_nf_Tcpwindow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Tcpurgp, kn) {
					currentKey = ffj_t_nf_Tcpurgp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Tcpurg, kn) {
					currentKey = ffj_t_nf_Tcpurg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpsyn, kn) {
					currentKey = ffj_t_nf_Tcpsyn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpsport, kn) {
					currentKey = ffj_t_nf_Tcpsport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpseq, kn) {
					currentKey = ffj_t_nf_Tcpseq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcprst, kn) {
					currentKey = ffj_t_nf_Tcprst
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpres2, kn) {
					currentKey = ffj_t_nf_Tcpres2
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpres1, kn) {
					currentKey = ffj_t_nf_Tcpres1
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpreserved, kn) {
					currentKey = ffj_t_nf_Tcpreserved
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcppsh, kn) {
					currentKey = ffj_t_nf_Tcppsh
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpoffset, kn) {
					currentKey = ffj_t_nf_Tcpoffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Tcpfin, kn) {
					currentKey = ffj_t_nf_Tcpfin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Tcpdport, kn) {
					currentKey = ffj_t_nf_Tcpdport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpcsum, kn) {
					currentKey = ffj_t_nf_Tcpcsum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpackseq, kn) {
					currentKey = ffj_t_nf_Tcpackseq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Tcpack, kn) {
					currentKey = ffj_t_nf_Tcpack
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Sumpkts, kn) {
					currentKey = ffj_t_nf_Sumpkts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Sumname, kn) {
					currentKey = ffj_t_nf_Sumname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Sumbytes, kn) {
					currentKey = ffj_t_nf_Sumbytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Sctpsport, kn) {
					currentKey = ffj_t_nf_Sctpsport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Sctpdport, kn) {
					currentKey = ffj_t_nf_Sctpdport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Sctpcsum, kn) {
					currentKey = ffj_t_nf_Sctpcsum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Replyrawpktlen, kn) {
					currentKey = ffj_t_nf_Replyrawpktlen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Replyrawpktcount, kn) {
					currentKey = ffj_t_nf_Replyrawpktcount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Replyl4sport, kn) {
					currentKey = ffj_t_nf_Replyl4sport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Replyl4dport, kn) {
					currentKey = ffj_t_nf_Replyl4dport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Replyipsaddrstr, kn) {
					currentKey = ffj_t_nf_Replyipsaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Replyipprotocol, kn) {
					currentKey = ffj_t_nf_Replyipprotocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Replyipdaddrstr, kn) {
					currentKey = ffj_t_nf_Replyipdaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Rawtype, kn) {
					currentKey = ffj_t_nf_Rawtype
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Rawpktlen, kn) {
					currentKey = ffj_t_nf_Rawpktlen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Rawpkt, kn) {
					currentKey = ffj_t_nf_Rawpkt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Rawpktcount, kn) {
					currentKey = ffj_t_nf_Rawpktcount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Rawmaclen, kn) {
					currentKey = ffj_t_nf_Rawmaclen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Rawmac, kn) {
					currentKey = ffj_t_nf_Rawmac
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Rawmacaddrlen, kn) {
					currentKey = ffj_t_nf_Rawmacaddrlen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Rawlabel, kn) {
					currentKey = ffj_t_nf_Rawlabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Pwsniffuser, kn) {
					currentKey = ffj_t_nf_Pwsniffuser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Pwsniffpass, kn) {
					currentKey = ffj_t_nf_Pwsniffpass
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_nf_Print, kn) {
					currentKey = ffj_t_nf_Print
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Origrawpktlen, kn) {
					currentKey = ffj_t_nf_Origrawpktlen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Origrawpktcount, kn) {
					currentKey = ffj_t_nf_Origrawpktcount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Origl4sport, kn) {
					currentKey = ffj_t_nf_Origl4sport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Origl4dport, kn) {
					currentKey = ffj_t_nf_Origl4dport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Origipsaddrstr, kn) {
					currentKey = ffj_t_nf_Origipsaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Origipprotocol, kn) {
					currentKey = ffj_t_nf_Origipprotocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Origipdaddrstr, kn) {
					currentKey = ffj_t_nf_Origipdaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobuid, kn) {
					currentKey = ffj_t_nf_Oobuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Oobtimeusec, kn) {
					currentKey = ffj_t_nf_Oobtimeusec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Oobtimesec, kn) {
					currentKey = ffj_t_nf_Oobtimesec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Oobseqlocal, kn) {
					currentKey = ffj_t_nf_Oobseqlocal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Oobseqglobal, kn) {
					currentKey = ffj_t_nf_Oobseqglobal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobprotocol, kn) {
					currentKey = ffj_t_nf_Oobprotocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobprefix, kn) {
					currentKey = ffj_t_nf_Oobprefix
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobout, kn) {
					currentKey = ffj_t_nf_Oobout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Oobmark, kn) {
					currentKey = ffj_t_nf_Oobmark
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobin, kn) {
					currentKey = ffj_t_nf_Oobin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobifindexout, kn) {
					currentKey = ffj_t_nf_Oobifindexout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobifindexin, kn) {
					currentKey = ffj_t_nf_Oobifindexin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Oobhook, kn) {
					currentKey = ffj_t_nf_Oobhook
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobgid, kn) {
					currentKey = ffj_t_nf_Oobgid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Oobfamily, kn) {
					currentKey = ffj_t_nf_Oobfamily
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Nufwusername, kn) {
					currentKey = ffj_t_nf_Nufwusername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Nufwuserid, kn) {
					currentKey = ffj_t_nf_Nufwuserid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Nufwosvers, kn) {
					currentKey = ffj_t_nf_Nufwosvers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Nufwosrel, kn) {
					currentKey = ffj_t_nf_Nufwosrel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Nufwosname, kn) {
					currentKey = ffj_t_nf_Nufwosname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Nufwappname, kn) {
					currentKey = ffj_t_nf_Nufwappname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Macstr, kn) {
					currentKey = ffj_t_nf_Macstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Macsaddrstr, kn) {
					currentKey = ffj_t_nf_Macsaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Macdaddrstr, kn) {
					currentKey = ffj_t_nf_Macdaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ipttl, kn) {
					currentKey = ffj_t_nf_Ipttl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Iptotlen, kn) {
					currentKey = ffj_t_nf_Iptotlen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Iptos, kn) {
					currentKey = ffj_t_nf_Iptos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Ipsaddrstr, kn) {
					currentKey = ffj_t_nf_Ipsaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ipprotocol, kn) {
					currentKey = ffj_t_nf_Ipprotocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ipihl, kn) {
					currentKey = ffj_t_nf_Ipihl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ipid, kn) {
					currentKey = ffj_t_nf_Ipid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ipfragoff, kn) {
					currentKey = ffj_t_nf_Ipfragoff
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Ipdaddrstr, kn) {
					currentKey = ffj_t_nf_Ipdaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Ipcsum, kn) {
					currentKey = ffj_t_nf_Ipcsum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ip6priority, kn) {
					currentKey = ffj_t_nf_Ip6priority
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ip6payloadlen, kn) {
					currentKey = ffj_t_nf_Ip6payloadlen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ip6nexthdr, kn) {
					currentKey = ffj_t_nf_Ip6nexthdr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ip6hoplimit, kn) {
					currentKey = ffj_t_nf_Ip6hoplimit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ip6fragoff, kn) {
					currentKey = ffj_t_nf_Ip6fragoff
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ip6fragid, kn) {
					currentKey = ffj_t_nf_Ip6fragid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ip6flowlabel, kn) {
					currentKey = ffj_t_nf_Ip6flowlabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Icmpv6type, kn) {
					currentKey = ffj_t_nf_Icmpv6type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Icmpv6echoseq, kn) {
					currentKey = ffj_t_nf_Icmpv6echoseq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Icmpv6echoid, kn) {
					currentKey = ffj_t_nf_Icmpv6echoid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Icmpv6csum, kn) {
					currentKey = ffj_t_nf_Icmpv6csum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Icmpv6code, kn) {
					currentKey = ffj_t_nf_Icmpv6code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Icmptype, kn) {
					currentKey = ffj_t_nf_Icmptype
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Icmpgateway, kn) {
					currentKey = ffj_t_nf_Icmpgateway
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Icmpfragmtu, kn) {
					currentKey = ffj_t_nf_Icmpfragmtu
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Icmpechoseq, kn) {
					currentKey = ffj_t_nf_Icmpechoseq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Icmpechoid, kn) {
					currentKey = ffj_t_nf_Icmpechoid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Icmpcsum, kn) {
					currentKey = ffj_t_nf_Icmpcsum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Icmpcode, kn) {
					currentKey = ffj_t_nf_Icmpcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Flowstartusec, kn) {
					currentKey = ffj_t_nf_Flowstartusec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Flowstartsec, kn) {
					currentKey = ffj_t_nf_Flowstartsec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Flowendusec, kn) {
					currentKey = ffj_t_nf_Flowendusec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Flowendsec, kn) {
					currentKey = ffj_t_nf_Flowendsec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Ctmark, kn) {
					currentKey = ffj_t_nf_Ctmark
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ctid, kn) {
					currentKey = ffj_t_nf_Ctid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Ctevent, kn) {
					currentKey = ffj_t_nf_Ctevent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Arpshwaddr, kn) {
					currentKey = ffj_t_nf_Arpshwaddr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Arpsaddrstr, kn) {
					currentKey = ffj_t_nf_Arpsaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Arpprotocoltype, kn) {
					currentKey = ffj_t_nf_Arpprotocoltype
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Arpoperation, kn) {
					currentKey = ffj_t_nf_Arpoperation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Arphwtype, kn) {
					currentKey = ffj_t_nf_Arphwtype
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_nf_Arpdhwaddr, kn) {
					currentKey = ffj_t_nf_Arpdhwaddr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Arpdaddrstr, kn) {
					currentKey = ffj_t_nf_Arpdaddrstr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_nf_Ahespspi, kn) {
					currentKey = ffj_t_nf_Ahespspi
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_nfno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_nf_Ahespspi:
					goto handle_Ahespspi

				case ffj_t_nf_Arpdaddrstr:
					goto handle_Arpdaddrstr

				case ffj_t_nf_Arpdhwaddr:
					goto handle_Arpdhwaddr

				case ffj_t_nf_Arphwtype:
					goto handle_Arphwtype

				case ffj_t_nf_Arpoperation:
					goto handle_Arpoperation

				case ffj_t_nf_Arpprotocoltype:
					goto handle_Arpprotocoltype

				case ffj_t_nf_Arpsaddrstr:
					goto handle_Arpsaddrstr

				case ffj_t_nf_Arpshwaddr:
					goto handle_Arpshwaddr

				case ffj_t_nf_Ctevent:
					goto handle_Ctevent

				case ffj_t_nf_Ctid:
					goto handle_Ctid

				case ffj_t_nf_Ctmark:
					goto handle_Ctmark

				case ffj_t_nf_Flowendsec:
					goto handle_Flowendsec

				case ffj_t_nf_Flowendusec:
					goto handle_Flowendusec

				case ffj_t_nf_Flowstartsec:
					goto handle_Flowstartsec

				case ffj_t_nf_Flowstartusec:
					goto handle_Flowstartusec

				case ffj_t_nf_Icmpcode:
					goto handle_Icmpcode

				case ffj_t_nf_Icmpcsum:
					goto handle_Icmpcsum

				case ffj_t_nf_Icmpechoid:
					goto handle_Icmpechoid

				case ffj_t_nf_Icmpechoseq:
					goto handle_Icmpechoseq

				case ffj_t_nf_Icmpfragmtu:
					goto handle_Icmpfragmtu

				case ffj_t_nf_Icmpgateway:
					goto handle_Icmpgateway

				case ffj_t_nf_Icmptype:
					goto handle_Icmptype

				case ffj_t_nf_Icmpv6code:
					goto handle_Icmpv6code

				case ffj_t_nf_Icmpv6csum:
					goto handle_Icmpv6csum

				case ffj_t_nf_Icmpv6echoid:
					goto handle_Icmpv6echoid

				case ffj_t_nf_Icmpv6echoseq:
					goto handle_Icmpv6echoseq

				case ffj_t_nf_Icmpv6type:
					goto handle_Icmpv6type

				case ffj_t_nf_Ip6flowlabel:
					goto handle_Ip6flowlabel

				case ffj_t_nf_Ip6fragid:
					goto handle_Ip6fragid

				case ffj_t_nf_Ip6fragoff:
					goto handle_Ip6fragoff

				case ffj_t_nf_Ip6hoplimit:
					goto handle_Ip6hoplimit

				case ffj_t_nf_Ip6nexthdr:
					goto handle_Ip6nexthdr

				case ffj_t_nf_Ip6payloadlen:
					goto handle_Ip6payloadlen

				case ffj_t_nf_Ip6priority:
					goto handle_Ip6priority

				case ffj_t_nf_Ipcsum:
					goto handle_Ipcsum

				case ffj_t_nf_Ipdaddrstr:
					goto handle_Ipdaddrstr

				case ffj_t_nf_Ipfragoff:
					goto handle_Ipfragoff

				case ffj_t_nf_Ipid:
					goto handle_Ipid

				case ffj_t_nf_Ipihl:
					goto handle_Ipihl

				case ffj_t_nf_Ipprotocol:
					goto handle_Ipprotocol

				case ffj_t_nf_Ipsaddrstr:
					goto handle_Ipsaddrstr

				case ffj_t_nf_Iptos:
					goto handle_Iptos

				case ffj_t_nf_Iptotlen:
					goto handle_Iptotlen

				case ffj_t_nf_Ipttl:
					goto handle_Ipttl

				case ffj_t_nf_Macdaddrstr:
					goto handle_Macdaddrstr

				case ffj_t_nf_Macsaddrstr:
					goto handle_Macsaddrstr

				case ffj_t_nf_Macstr:
					goto handle_Macstr

				case ffj_t_nf_Nufwappname:
					goto handle_Nufwappname

				case ffj_t_nf_Nufwosname:
					goto handle_Nufwosname

				case ffj_t_nf_Nufwosrel:
					goto handle_Nufwosrel

				case ffj_t_nf_Nufwosvers:
					goto handle_Nufwosvers

				case ffj_t_nf_Nufwuserid:
					goto handle_Nufwuserid

				case ffj_t_nf_Nufwusername:
					goto handle_Nufwusername

				case ffj_t_nf_Oobfamily:
					goto handle_Oobfamily

				case ffj_t_nf_Oobgid:
					goto handle_Oobgid

				case ffj_t_nf_Oobhook:
					goto handle_Oobhook

				case ffj_t_nf_Oobifindexin:
					goto handle_Oobifindexin

				case ffj_t_nf_Oobifindexout:
					goto handle_Oobifindexout

				case ffj_t_nf_Oobin:
					goto handle_Oobin

				case ffj_t_nf_Oobmark:
					goto handle_Oobmark

				case ffj_t_nf_Oobout:
					goto handle_Oobout

				case ffj_t_nf_Oobprefix:
					goto handle_Oobprefix

				case ffj_t_nf_Oobprotocol:
					goto handle_Oobprotocol

				case ffj_t_nf_Oobseqglobal:
					goto handle_Oobseqglobal

				case ffj_t_nf_Oobseqlocal:
					goto handle_Oobseqlocal

				case ffj_t_nf_Oobtimesec:
					goto handle_Oobtimesec

				case ffj_t_nf_Oobtimeusec:
					goto handle_Oobtimeusec

				case ffj_t_nf_Oobuid:
					goto handle_Oobuid

				case ffj_t_nf_Origipdaddrstr:
					goto handle_Origipdaddrstr

				case ffj_t_nf_Origipprotocol:
					goto handle_Origipprotocol

				case ffj_t_nf_Origipsaddrstr:
					goto handle_Origipsaddrstr

				case ffj_t_nf_Origl4dport:
					goto handle_Origl4dport

				case ffj_t_nf_Origl4sport:
					goto handle_Origl4sport

				case ffj_t_nf_Origrawpktcount:
					goto handle_Origrawpktcount

				case ffj_t_nf_Origrawpktlen:
					goto handle_Origrawpktlen

				case ffj_t_nf_Print:
					goto handle_Print

				case ffj_t_nf_Pwsniffpass:
					goto handle_Pwsniffpass

				case ffj_t_nf_Pwsniffuser:
					goto handle_Pwsniffuser

				case ffj_t_nf_Rawlabel:
					goto handle_Rawlabel

				case ffj_t_nf_Rawmacaddrlen:
					goto handle_Rawmacaddrlen

				case ffj_t_nf_Rawmac:
					goto handle_Rawmac

				case ffj_t_nf_Rawmaclen:
					goto handle_Rawmaclen

				case ffj_t_nf_Rawpktcount:
					goto handle_Rawpktcount

				case ffj_t_nf_Rawpkt:
					goto handle_Rawpkt

				case ffj_t_nf_Rawpktlen:
					goto handle_Rawpktlen

				case ffj_t_nf_Rawtype:
					goto handle_Rawtype

				case ffj_t_nf_Replyipdaddrstr:
					goto handle_Replyipdaddrstr

				case ffj_t_nf_Replyipprotocol:
					goto handle_Replyipprotocol

				case ffj_t_nf_Replyipsaddrstr:
					goto handle_Replyipsaddrstr

				case ffj_t_nf_Replyl4dport:
					goto handle_Replyl4dport

				case ffj_t_nf_Replyl4sport:
					goto handle_Replyl4sport

				case ffj_t_nf_Replyrawpktcount:
					goto handle_Replyrawpktcount

				case ffj_t_nf_Replyrawpktlen:
					goto handle_Replyrawpktlen

				case ffj_t_nf_Sctpcsum:
					goto handle_Sctpcsum

				case ffj_t_nf_Sctpdport:
					goto handle_Sctpdport

				case ffj_t_nf_Sctpsport:
					goto handle_Sctpsport

				case ffj_t_nf_Sumbytes:
					goto handle_Sumbytes

				case ffj_t_nf_Sumname:
					goto handle_Sumname

				case ffj_t_nf_Sumpkts:
					goto handle_Sumpkts

				case ffj_t_nf_Tcpack:
					goto handle_Tcpack

				case ffj_t_nf_Tcpackseq:
					goto handle_Tcpackseq

				case ffj_t_nf_Tcpcsum:
					goto handle_Tcpcsum

				case ffj_t_nf_Tcpdport:
					goto handle_Tcpdport

				case ffj_t_nf_Tcpfin:
					goto handle_Tcpfin

				case ffj_t_nf_Tcpoffset:
					goto handle_Tcpoffset

				case ffj_t_nf_Tcppsh:
					goto handle_Tcppsh

				case ffj_t_nf_Tcpreserved:
					goto handle_Tcpreserved

				case ffj_t_nf_Tcpres1:
					goto handle_Tcpres1

				case ffj_t_nf_Tcpres2:
					goto handle_Tcpres2

				case ffj_t_nf_Tcprst:
					goto handle_Tcprst

				case ffj_t_nf_Tcpseq:
					goto handle_Tcpseq

				case ffj_t_nf_Tcpsport:
					goto handle_Tcpsport

				case ffj_t_nf_Tcpsyn:
					goto handle_Tcpsyn

				case ffj_t_nf_Tcpurg:
					goto handle_Tcpurg

				case ffj_t_nf_Tcpurgp:
					goto handle_Tcpurgp

				case ffj_t_nf_Tcpwindow:
					goto handle_Tcpwindow

				case ffj_t_nf_Udpcsum:
					goto handle_Udpcsum

				case ffj_t_nf_Udpdport:
					goto handle_Udpdport

				case ffj_t_nf_Udplen:
					goto handle_Udplen

				case ffj_t_nf_Udpsport:
					goto handle_Udpsport

				case ffj_t_nf_Srcport:
					goto handle_Srcport

				case ffj_t_nf_Srcip:
					goto handle_Srcip

				case ffj_t_nf_Destport:
					goto handle_Destport

				case ffj_t_nf_Destip:
					goto handle_Destip

				case ffj_t_nf_Dvc:
					goto handle_Dvc

				case ffj_t_nf_Timestamp:
					goto handle_Timestamp

				case ffj_t_nf_Ltimestamp:
					goto handle_Ltimestamp

				case ffj_t_nf_Action:
					goto handle_Action

				case ffj_t_nf_GeoIP:
					goto handle_GeoIP

				case ffj_t_nfno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ahespspi:

	/* handler: uj.Ahespspi type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ahespspi = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ahespspi = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arpdaddrstr:

	/* handler: uj.Arpdaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Arpdaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Arpdaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arpdhwaddr:

	/* handler: uj.Arpdhwaddr type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Arpdhwaddr = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Arpdhwaddr = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arphwtype:

	/* handler: uj.Arphwtype type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Arphwtype = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Arphwtype = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arpoperation:

	/* handler: uj.Arpoperation type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Arpoperation = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Arpoperation = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arpprotocoltype:

	/* handler: uj.Arpprotocoltype type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Arpprotocoltype = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Arpprotocoltype = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arpsaddrstr:

	/* handler: uj.Arpsaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Arpsaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Arpsaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arpshwaddr:

	/* handler: uj.Arpshwaddr type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Arpshwaddr = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Arpshwaddr = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ctevent:

	/* handler: uj.Ctevent type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ctevent = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ctevent = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ctid:

	/* handler: uj.Ctid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ctid = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ctid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ctmark:

	/* handler: uj.Ctmark type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ctmark = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ctmark = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flowendsec:

	/* handler: uj.Flowendsec type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Flowendsec = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Flowendsec = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flowendusec:

	/* handler: uj.Flowendusec type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Flowendusec = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Flowendusec = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flowstartsec:

	/* handler: uj.Flowstartsec type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Flowstartsec = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Flowstartsec = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Flowstartusec:

	/* handler: uj.Flowstartusec type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Flowstartusec = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Flowstartusec = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpcode:

	/* handler: uj.Icmpcode type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpcode = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpcode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpcsum:

	/* handler: uj.Icmpcsum type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpcsum = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpcsum = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpechoid:

	/* handler: uj.Icmpechoid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpechoid = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpechoid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpechoseq:

	/* handler: uj.Icmpechoseq type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpechoseq = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpechoseq = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpfragmtu:

	/* handler: uj.Icmpfragmtu type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpfragmtu = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpfragmtu = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpgateway:

	/* handler: uj.Icmpgateway type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpgateway = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpgateway = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmptype:

	/* handler: uj.Icmptype type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmptype = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmptype = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpv6code:

	/* handler: uj.Icmpv6code type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpv6code = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpv6code = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpv6csum:

	/* handler: uj.Icmpv6csum type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpv6csum = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpv6csum = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpv6echoid:

	/* handler: uj.Icmpv6echoid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpv6echoid = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpv6echoid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpv6echoseq:

	/* handler: uj.Icmpv6echoseq type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpv6echoseq = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpv6echoseq = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Icmpv6type:

	/* handler: uj.Icmpv6type type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Icmpv6type = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Icmpv6type = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip6flowlabel:

	/* handler: uj.Ip6flowlabel type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ip6flowlabel = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ip6flowlabel = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip6fragid:

	/* handler: uj.Ip6fragid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ip6fragid = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ip6fragid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip6fragoff:

	/* handler: uj.Ip6fragoff type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ip6fragoff = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ip6fragoff = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip6hoplimit:

	/* handler: uj.Ip6hoplimit type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ip6hoplimit = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ip6hoplimit = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip6nexthdr:

	/* handler: uj.Ip6nexthdr type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ip6nexthdr = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ip6nexthdr = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip6payloadlen:

	/* handler: uj.Ip6payloadlen type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ip6payloadlen = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ip6payloadlen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip6priority:

	/* handler: uj.Ip6priority type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ip6priority = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ip6priority = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ipcsum:

	/* handler: uj.Ipcsum type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ipcsum = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ipcsum = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ipdaddrstr:

	/* handler: uj.Ipdaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Ipdaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Ipdaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ipfragoff:

	/* handler: uj.Ipfragoff type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ipfragoff = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ipfragoff = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ipid:

	/* handler: uj.Ipid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ipid = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ipid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ipihl:

	/* handler: uj.Ipihl type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ipihl = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ipihl = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ipprotocol:

	/* handler: uj.Ipprotocol type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ipprotocol = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ipprotocol = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ipsaddrstr:

	/* handler: uj.Ipsaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Ipsaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Ipsaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Iptos:

	/* handler: uj.Iptos type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Iptos = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Iptos = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Iptotlen:

	/* handler: uj.Iptotlen type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Iptotlen = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Iptotlen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ipttl:

	/* handler: uj.Ipttl type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ipttl = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Ipttl = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Macdaddrstr:

	/* handler: uj.Macdaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Macdaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Macdaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Macsaddrstr:

	/* handler: uj.Macsaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Macsaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Macsaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Macstr:

	/* handler: uj.Macstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Macstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Macstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nufwappname:

	/* handler: uj.Nufwappname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Nufwappname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Nufwappname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nufwosname:

	/* handler: uj.Nufwosname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Nufwosname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Nufwosname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nufwosrel:

	/* handler: uj.Nufwosrel type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Nufwosrel = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Nufwosrel = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nufwosvers:

	/* handler: uj.Nufwosvers type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Nufwosvers = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Nufwosvers = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nufwuserid:

	/* handler: uj.Nufwuserid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Nufwuserid = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Nufwuserid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nufwusername:

	/* handler: uj.Nufwusername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Nufwusername = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Nufwusername = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobfamily:

	/* handler: uj.Oobfamily type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobfamily = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobfamily = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobgid:

	/* handler: uj.Oobgid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobgid = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobgid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobhook:

	/* handler: uj.Oobhook type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobhook = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobhook = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobifindexin:

	/* handler: uj.Oobifindexin type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobifindexin = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobifindexin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobifindexout:

	/* handler: uj.Oobifindexout type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobifindexout = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobifindexout = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobin:

	/* handler: uj.Oobin type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Oobin = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Oobin = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobmark:

	/* handler: uj.Oobmark type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobmark = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobmark = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobout:

	/* handler: uj.Oobout type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Oobout = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Oobout = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobprefix:

	/* handler: uj.Oobprefix type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Oobprefix = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Oobprefix = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobprotocol:

	/* handler: uj.Oobprotocol type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobprotocol = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobprotocol = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobseqglobal:

	/* handler: uj.Oobseqglobal type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobseqglobal = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobseqglobal = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobseqlocal:

	/* handler: uj.Oobseqlocal type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobseqlocal = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobseqlocal = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobtimesec:

	/* handler: uj.Oobtimesec type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobtimesec = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobtimesec = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobtimeusec:

	/* handler: uj.Oobtimeusec type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobtimeusec = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobtimeusec = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oobuid:

	/* handler: uj.Oobuid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Oobuid = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Oobuid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Origipdaddrstr:

	/* handler: uj.Origipdaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Origipdaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Origipdaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Origipprotocol:

	/* handler: uj.Origipprotocol type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Origipprotocol = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Origipprotocol = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Origipsaddrstr:

	/* handler: uj.Origipsaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Origipsaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Origipsaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Origl4dport:

	/* handler: uj.Origl4dport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Origl4dport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Origl4dport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Origl4sport:

	/* handler: uj.Origl4sport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Origl4sport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Origl4sport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Origrawpktcount:

	/* handler: uj.Origrawpktcount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Origrawpktcount = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Origrawpktcount = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Origrawpktlen:

	/* handler: uj.Origrawpktlen type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Origrawpktlen = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Origrawpktlen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Print:

	/* handler: uj.Print type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Print = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Print = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pwsniffpass:

	/* handler: uj.Pwsniffpass type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Pwsniffpass = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Pwsniffpass = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pwsniffuser:

	/* handler: uj.Pwsniffuser type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Pwsniffuser = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Pwsniffuser = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rawlabel:

	/* handler: uj.Rawlabel type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Rawlabel = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Rawlabel = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rawmacaddrlen:

	/* handler: uj.Rawmacaddrlen type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Rawmacaddrlen = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Rawmacaddrlen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rawmac:

	/* handler: uj.Rawmac type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Rawmac = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Rawmac = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rawmaclen:

	/* handler: uj.Rawmaclen type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Rawmaclen = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Rawmaclen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rawpktcount:

	/* handler: uj.Rawpktcount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Rawpktcount = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Rawpktcount = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rawpkt:

	/* handler: uj.Rawpkt type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Rawpkt = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Rawpkt = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rawpktlen:

	/* handler: uj.Rawpktlen type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Rawpktlen = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Rawpktlen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rawtype:

	/* handler: uj.Rawtype type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Rawtype = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Rawtype = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Replyipdaddrstr:

	/* handler: uj.Replyipdaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Replyipdaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Replyipdaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Replyipprotocol:

	/* handler: uj.Replyipprotocol type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Replyipprotocol = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Replyipprotocol = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Replyipsaddrstr:

	/* handler: uj.Replyipsaddrstr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Replyipsaddrstr = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Replyipsaddrstr = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Replyl4dport:

	/* handler: uj.Replyl4dport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Replyl4dport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Replyl4dport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Replyl4sport:

	/* handler: uj.Replyl4sport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Replyl4sport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Replyl4sport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Replyrawpktcount:

	/* handler: uj.Replyrawpktcount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Replyrawpktcount = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Replyrawpktcount = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Replyrawpktlen:

	/* handler: uj.Replyrawpktlen type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Replyrawpktlen = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Replyrawpktlen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sctpcsum:

	/* handler: uj.Sctpcsum type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Sctpcsum = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Sctpcsum = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sctpdport:

	/* handler: uj.Sctpdport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Sctpdport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Sctpdport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sctpsport:

	/* handler: uj.Sctpsport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Sctpsport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Sctpsport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sumbytes:

	/* handler: uj.Sumbytes type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Sumbytes = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Sumbytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sumname:

	/* handler: uj.Sumname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Sumname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Sumname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sumpkts:

	/* handler: uj.Sumpkts type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Sumpkts = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Sumpkts = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpack:

	/* handler: uj.Tcpack type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpack = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpack = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpackseq:

	/* handler: uj.Tcpackseq type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpackseq = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpackseq = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpcsum:

	/* handler: uj.Tcpcsum type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpcsum = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpcsum = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpdport:

	/* handler: uj.Tcpdport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpdport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpdport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpfin:

	/* handler: uj.Tcpfin type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpfin = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpfin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpoffset:

	/* handler: uj.Tcpoffset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpoffset = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpoffset = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcppsh:

	/* handler: uj.Tcppsh type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcppsh = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcppsh = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpreserved:

	/* handler: uj.Tcpreserved type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpreserved = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpreserved = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpres1:

	/* handler: uj.Tcpres1 type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpres1 = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpres1 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpres2:

	/* handler: uj.Tcpres2 type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpres2 = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpres2 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcprst:

	/* handler: uj.Tcprst type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcprst = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcprst = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpseq:

	/* handler: uj.Tcpseq type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpseq = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpseq = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpsport:

	/* handler: uj.Tcpsport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpsport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpsport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpsyn:

	/* handler: uj.Tcpsyn type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpsyn = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpsyn = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpurg:

	/* handler: uj.Tcpurg type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpurg = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpurg = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpurgp:

	/* handler: uj.Tcpurgp type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpurgp = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpurgp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tcpwindow:

	/* handler: uj.Tcpwindow type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tcpwindow = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Tcpwindow = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Udpcsum:

	/* handler: uj.Udpcsum type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Udpcsum = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Udpcsum = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Udpdport:

	/* handler: uj.Udpdport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Udpdport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Udpdport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Udplen:

	/* handler: uj.Udplen type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Udplen = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Udplen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Udpsport:

	/* handler: uj.Udpsport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Udpsport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Udpsport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Srcport:

	/* handler: uj.Srcport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Srcport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Srcport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Srcip:

	/* handler: uj.Srcip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Srcip = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Srcip = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Destport:

	/* handler: uj.Destport type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Destport = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Destport = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Destip:

	/* handler: uj.Destip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Destip = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Destip = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dvc:

	/* handler: uj.Dvc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Dvc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Dvc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: uj.Timestamp type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Timestamp = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Timestamp = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ltimestamp:

	/* handler: uj.Ltimestamp type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Ltimestamp = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Action:

	/* handler: uj.Action type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Action = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Action = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GeoIP:

	/* handler: uj.GeoIP type=main.esGeoIP kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.GeoIP.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
